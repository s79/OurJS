<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>OurJS Overview</title>
<link rel="stylesheet" href="/stylesheets/common.css">
<link rel="stylesheet" href="stylesheets/framework.css">
<script src="../our.js"></script>
<script src="/scripts/common.js"></script>
<style>
.example { list-style-type: circle; padding: 5px 5px 5px 2em; border: 1px solid #dcdcdc; border-radius: 5px; background: #f5f5f5; }
.example li { margin: 15px 0; }
.example p { margin: 5px 0; }
.example code { color: sienna; }
pre span,
code span { border: 1px solid #9acd32; background: #f8fff8; }
</style>
</head>
<body>
<div id="content">
  <h1>OurJS 概述</h1>

  <h2>要求</h2>
  <p>OurJS 是一个适用于 WEB 应用开发的 JavaScript 快速开发框架，使用 OurJS 的开发者只需要有 JavaScript 和 DOM 的一些基础知识<sup>1</sup>，即可编写出兼容各主流浏览器（指 IE6 IE7 IE8 IE9 Firefox Chrome Safari Opera 以及其他使用 Trident 和 WebKit 内核的浏览器）的 WEB 应用。</p>
  <p>OurJS 要求浏览器运行在“标准模式”下<sup>2</sup>，当浏览器工作在非标准模式下时，开发者将收到一条警告信息。</p>
  <p>OurJS 具备完善的功能，也提供了基于组件形式的扩展，因此能够应对大部分需求。<br>当必须引入其他的类库以满足特定需求时，要注意一点：OurJS 使用了侵入式设计，因此只能和其他非侵入式设计的类库<sup>3</sup>共存。</p>
  <ol class="comment">
    <li>开发者要了解 JS 的变量、数据类型、运算符、流程控制，以及 DOM 的一些常见的 API。</li>
    <li>这是为了强制开发者编写符合标准规范的代码，以获得更好的兼容性，并发挥浏览器的最大功效。</li>
    <li>可以和 jQuery 共存。</li>
  </ol>

  <h2>特点</h2>
  <p>
    与其他 JavaScript 框架（类库）相比，OurJS 要更加<strong>简单</strong><sup>1</sup>，更易于理解和使用。<br>
    使 OurJS 变得“简单”的，是以下几个特点：
  </p>

  <h3>语法自然 —— 提供向标准靠拢<sup>2</sup>的、语义明确<sup>3</sup>的 API。</h3>
  <ul>
    <li>
      <p>
        对于一些在新的规范（草案）中定义的，或已成为事实标准的特性，在尚未支持的浏览器上通过技术手段予以补缺。<br>
        这些 API 的语法是最自然的，使用它们时，开发者像面对最新的浏览器一样写代码，甚至感觉不到 OurJS 的存在。<br>
        举例如下：
      </p>
      <ul class="example">
        <li>
          <p><code>anArray.<span>forEach</span>(function(item) {...});</code></p>
          <p class="comment">Array 对象的 forEach 方法是 ECMAScript 5 引入的，本来只有在较新版本的浏览器中才能使用，但现在可以放心使用了。</p>
        </li>
        <li>
          <p><code>if (aString.<span>startsWith</span>('ex-') {...}</code></p>
          <p class="comment">ECMAScript 6 (Harmony) 中的提案：检查字符串是否以指定的子串开始。这个方法很实用，有助于提高代码的可读性。</p>
        </li>
        <li>
          <p><code><span>localStorage.setItem</span>('data', <span>JSON.stringify</span>(userData));</code></p>
          <p class="comment">HTML5 的 localStorage 对象和 ECMAScript 5 的 JSON 对象原本在 IE6 IE7 中是不支持的，但现在可以放心使用了。</p>
        </li>
        <li>
          <p><code><span>Element.prototype</span>.newMethod = function() {...};</code></p>
          <p class="comment">IE6 IE7 本来没有 Element 构造函数，但现在可以通过扩充 Element.prototype 来为页面上的 DOM 元素添加新特性了。</p>
        </li>
        <li>
          <p><code>element.<span>outerHTML</span> = '&lt;h1&gt;OK&lt;/h1&gt;';</code></p>
          <p class="comment">元素的 outerHTML 特性是 IE 最先引入的，目前只有 Firefox 不支持，但现在可以放心使用了。</p>
        </li>
      </ul>
    </li>
    <li>
      <p>
        对于有规范支持但无法通过技术手段实现补缺的，或者无规范支持仅为方便使用而提供的特性，以扩展的方式提供。<br>
        这些扩展的 API 语义明确，容易记忆，具备“自注释”的特性，力求和源生 API 的语法一样自然。<br>
        举例如下：
      </p>
      <ul class="example">
        <li>
          <p><code>element.<span>setStyles({position: 'fixed', right: 0, bottom: 0})</span>;</code></p>
          <p class="comment">
            IE6 并不支持 CSS2 引入的固定定位，但现在通过使用 element.setStyle/setStyles 方法，可以实现在各浏览器中的一致的表现，而使用 element.getStyle/getStyles，也将获得预期的返回值 'fixed'。<br>
            值得注意的是，setStyles 是设置多个样式，而 setStyle 是设置一个样式，二者的用途不同、名称不同、参数也不相同。
          </p>
        </li>
        <li>
          <p><code>element.<span>on</span>('click', function(e) {...});</code></p>
          <p class="comment">IE6 IE7 IE8 的事件模型与其他浏览器的不同，但现在可以通过 element.on/off/fire 方法实在各浏览器通用的事件处理函数的绑定/解除绑定/触发了。</p>
        </li>
        <li>
          <p><code>var nextElement = element.<span>getNext</span>();</code></p>
          <p class="comment">要获取一个元素的下一个相邻元素，在 Element Traversal Specification 中推荐的、指定获取元素类型节点的 nextElementSibling 属性仅在较新的浏览器中才支持，在 IE6 IE7 IE8 中只能通过该元素的 nextSibling 属性获取，不过这需要进一步判断，因为得到的可能是一个文本节点，但现在可以在所有浏览器上通过调用元素的 getNext 方法而达到相同的目的了。</p>
        </li>
        <li>
          <p><code>element.<span>addClass</span>('active').<span>putBefore</span>(anotherElement);</code></p>
          <p class="comment">给元素添加一个类名，然后插入到另一个元素的前边。这个需求也可以使用其他无兼容性问题的途径来实现，扩展这两个方法仅是为了方便使用。</p>
        </li>
        <li>
          <p><code>Array.<span>from</span>(element.getElementsByTagName('select')).forEach(function(item){...});</code></p>
          <p class="comment">将一个 NodeList 对象（或其他任意数据类型）转化为数组，以便使用数组的方法进行操作。Array.from 目前尚无规范支持，是仅为方便使用而添加的属性。</p>
        </li>
      </ul>
    </li>
  </ul>

  <h3>思路清晰 —— 对于一个问题只提供唯一的、最通用的解决方案<sup>4</sup>。</h3>
  <ul>
    <li>
      唯一的解决方案更利于理解和记忆，而多个可选的解决方案在提供便利的同时，也增加了理解和记忆的复杂度。<br>
      举例如下：<br>
      <ul class="example">
        <li>
          <p>假设 DOM 树中已有一个元素 <code>A</code>，现在要在它的后边插入一个元素 <code>B</code>。</p>
          <p>
            使用 OurJS 的解决方案是 <code>B.putAfter(A)</code>。<br>
            OurJS 并没有提供其他的方法来做这件事情，像是 <code>A.someMethod(B)</code> 这样的方法是不存在的，因此只需要记住一个语义很明确的 <code>putAfter</code> 方法即可。
          </p>
          <p class="comment">
            对于上述问题，有的库提供了两种解决方案，比如分别是 <code>A.after(B)</code> 和 <code>B.insertAfter(A)</code>。<br>
            事实上 <code>after</code> 和 <code>insertAfter</code> 的语义并不明确，除非开发者对 API 有足够的了解，否则很容易将二者混淆，从而带来意料之外的麻烦。
          </p>
        </li>
        <li>
          <p>使用正则表达式 <code>regExp</code> 在字符串 <code>string</code> 中进行匹配，返回匹配结果。</p>
          <p>最普遍的解决方案是 <code>string.match(regExp)</code>，这很容易理解。OurJS 也没有提供其他的方法来做这件事。</p>
          <p class="comment">
            对于上述问题，有的库扩展了 <code>RegExp.prototype.match</code> 方法，并为其提供与 <code>String.prototype.match</code> 相同的行为。<br>
            在这种情况下，使用这个库的开发者可以使用两种不同的解决方案：<code>string.match(regExp)</code> 和 <code>regExp.match(string)</code>。<br>
            这种“灵活”带来的代价，是混淆常见 API 的用法，这将会导致记忆混乱，浪费不必要的精力。
          </p>
        </li>
      </ul>
    </li>
  </ul>

  <h3>风格一致 —— 只要掌握了部分用法，就可以轻易的推测出其他部分的用法。</h3>
  <ul>
    <li></li>
  </ul>

  <h3>功能完善 —— 提供粒度恰当<sup>5</sup>的功能和组件，可以通过灵活的配置和组合进行自由的设计。</h3>
  <ul>
    <li></li>
  </ul>

  <ol class="comment">
    <li>
      此处所说的“简单”不是指功能单一，实际上，OurJS 的功能要超过一些常见的类库。<br>
      简单是相对于复杂而言的，描述的是人们的感觉。<br>
      通常，使用可预期的 API 自由的编程是更简单的。而一旦某个 API 让人感到意外或被束缚，就会令人困惑和厌烦，这样的事情如果一再发生，原本简单的事情也会觉得复杂。<br>
    </li>
  </ol>
  <blockquote>
    <p>"Everything should be made as simple as possible, but no simpler." -- Albert Einstein<br>
      “任何事情都应该尽可能的做到简单，简单到极致。”—— 爱因斯坦
    </p>
  </blockquote>

  <p>面对复杂的需求，OurJS 提供了“模块 - 应用”机制来化繁为简：将可分离的业务逻辑拆分为多个模块，再通过应用将各模块连接起来。其中每个模块都是完全独立的，有利于协同开发和单元测试。</p>

  <p>
    <em>TODO: 关于 API 一致性的描述。举以下几个例子：</em>
  </p>
  <ul>
    <li><em>无包装的 DOM 元素。</em></li>
    <li><em>只有一个可选参数。</em></li>
    <li><em>DOM 元素的事件处理。</em></li>
    <li><em>组件的事件处理。</em></li>
    <li><em>可重复使用的功能和一次性使用的功能。</em></li>
  </ul>


</div>
</body>
</html>
