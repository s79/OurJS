>--------------------------------------------------[备忘]
>Features
“特性”是指可以应用于任意对象上的功能。
将某种“特性”应用到某个对象后，该对象将具备特定的功能。
“特性”不宜作为某一类对象的实例方法，是因为它们除了提供特殊方法外，可能还需要附加的属性。


>Shadow Object
是否还有必要为了避免 IE6 的内存泄漏而使用比较麻烦的方法编写库和组件？
泄漏主要是由于 DOM 对象的事件监听器的作用域链有对 DOM 对象的引用。
而且在 XP sp3 版本的 IE6，只要不将这些 DOM 对象从文档树中移除，很难察觉是否还存在内存泄漏问题。
目前的方式是为元素设定 uid 作为该元素的 key，并在必要时建立“影子对象”，在其中保存扩展的内容（包括监听器）。
“影子对象”与 DOM 对象是通过 uid 关联的，要保证在 DOM 对象被丢弃的时候清理“影子对象”，就要封装所有相关的方法(1)。
  - 事实上目前主流的库也没有特地处理这种情况，因为不做二者的同步问题也不大，在离开本页后“影子对象”可以被正常回收。
但如果不使用“影子对象”，将数据直接保存在 DOM 对象上，即可避免处理这种同步的问题，而且可以简化编码，使逻辑更清晰。
  - 目前 IE6 在国内的份额是 25% 左右，非企业应用的情况下内存泄漏造成的影响并不严重。
若在不使用“影子对象”的情况下避免 IE6 的内存泄漏，可以使用上述(1)中提到的方式，封装能够导致 DOM 对象被丢弃的方法（remove、replace、innerHTML、outerHTML、innerText、outerText、deleteRow 等）来解决问题。


>UIComponent -> Widget
目前构造器形式的 UI 组件均至少依赖一个已经存在于文档树中的元素，且几乎不会出现将一个元素作为多个 UI 组件的“源”使用的情况。
因此考虑将 UI 组件逐步替换为以 widget-type 元素直接植入 HTML 代码的形式，以使 UI 组件的代码更紧凑，更易用。

# 创建新对象，相关逻辑由这个对象控制。
优点：
* 方法名/事件名随意设置，不必担心命名冲突。
缺点：
* 多了一个对象，而这个对象的所有方法其实都在修改一个元素或其后代元素在 DOM 树中的状态。

# 直接扩展目标元素，为其添加新方法。
优点：
* 新添加的方法正是修改目标元素或其后代元素在 DOM 树中的状态，调用起来更方便。
* 直接使用框架提供的 DOM 事件处理机制，所有触发的事件都可以通过 DOM 树向上传播。
缺点：
* 给方法/事件命名时要避免命名冲突。

#需要考虑的问题有以下几点：
  * 针对 html 的解析及后续的修改、克隆操作，目前要实现能与浏览器的行为近似的功能比较困难(!)，因此对一致性略有影响。
    牺牲一些“一致性”来换取更重要的“易用性”是值得考虑的。
  * 初始化时需要多个元素的 UI 组件，通过约定这些元素的 class 来标识。
  * 所有相关数据，初始化需要的从 attribute 中获取，实例化之后的直接保存在 DOM 对象上。
    对于保存基本类型数据的 attribute 和 property，应有双向绑定(!)。事件相关的 onXXX attribute 则不必（二者类型不同）。
    这些属性只是作为配置参数，不需要在发生变化后立即响应，因此以自定义属性 data-XXX 来实现，其本身也有“配置参数”的语义。
  * Observable 特性以 DOM 事件的方式提供。
    TODO: 需重写事件处理部分，禁止所有非标准 DOM 事件在 DOM 树中传播。


>API 设计
可选参数不再强制为一个 options，必要时应归类以保持同类方法的参数含义相同。

简单、自然、完整、一致、易扩展。

API必须要提供充分的功能，以供调用者完成自己的任务。
API应该是最精简的，不要为调用者带来多余的不便。
如果没有理解API的使用环境的话，那也就不能去设计它。
通用性的API应当是与具体使用场景无关的，而特定用途的API则要充分考虑使用策略。
API应该从调用者的角度来进行设计。
好的API绝不推卸责任，把自己该做的事情留给别人。
在实现API之前，就应该把API文档化。
好的API应当符合工效学。

#http://www.slideshare.net/Dmitry.Baranovskiy/your-javascript-library
Everything should be made as simple as possible, but no simpler.


>inherit
extends 只能逐级继承，应使用原型链。
implement 可以并行实现多个“接口”（实际也应用各构造器），应使用原型拷贝。


>必须以 $ 获取元素为临时性要求，当不再为 IE6 IE7 提供支持时可弃用。


>our.js + suite 用于解决某一类应用的 API 易用性问题。


>IE9- delete -> removeAttriburte


>--------------------------------------------------[已完成或已取消的计划]
/*
TODO: [LOW] 避免多次 fix 同一个同类型的 DOM 事件对象。
DONE: 以上取消，因为 IE6 IE7 IE8 无法避免，在这些浏览器中，每个监听器传入的事件对象都是不同的。
      其他浏览器中虽然可以避免，但为了保持一致，并简化逻辑、提高效率（事实上同一事件被不同节点监听的情况相对来说是很罕见的），也不做处理。
      在 jQuery 1.7.1 中也未做此处理。

TODO: [LOW] fadeIn/fadeOut 逻辑合并；animation.stop 方法缺少恢复初始状态的功能（考虑到通过事件添加的非线性变换，此功能难以实现，暂建议在 playstart 事件发生时手动处理）。
DONE: 已实现。

TODO: 添加事件监听器时增加 :once 特性。
DONE: 以上取消，它使 API 变复杂。可以通过 label 来手动实现 once 或者 twice 之类的功能。

TODO: components 的 options 参数，应区分为“可改写”和“不可改写”两种，“不可改写”的不要附加在实例上。
DONE: 以上取消，太复杂。
      现在的方式是将选项保存到实例的 options 属性内。既然叫做“选项”，就应该让它们都可以改写，并且能在特定的时机生效。

TODO: 事件部分 fire 参数由 type 改为 name。
DONE: 不会实施这个修改，这会把事情变复杂。如果需要触发特定的一些监听器，应该为它们单独指定 type。

TODO: Animation 继续参考 CSS3 Transition，增加 delay 参数，并对外暴露 timingFunction。
      [low] 添加反向动画支持。
DONE: Animation 已使用新的思路设计，上述内容全部可以实现。

TODO: 以下命令不符合预期，应考虑加入 deffered 类型。
      或者加入在调用 stopAnimation 也会触发的 onComplete 回调，这样就可以在 onComplete 里加入状态处理的代码，而在 onFinish 中加入其他（如动画队列）代码。
      bodyMask.show().hide().show().hide().show().hide().show();
DONE: 使用新的 Animation 即可解决上述问题。
*/


>Global
>Object
>Function
>Array
>String
>Boolean
>Number
>Math
>Date
>RegExp
>Error
>JSON


>--------------------------------------------------[注释风格]
/**
 * @fileOverview <文件描述>
 * @author <作者信息>
 * @version <版本号 - 日期>
 */

(function() {
<本模块的公用变量>

//==================================================[<代码块标题>]
  /*
   * <代码块详细描述>
   */

<本代码块的公用变量>

//--------------------------------------------------[<方法/属性说明>]
  /*
   * <不想添加到文档的附加说明>
   */
  /**
   * <短描述>
   * @name <名称>
   * @memberOf <隶属对象>
   * @constructor @function @namespace @type <值类型>
   * @private
   * @param {<类型1|类型2>} <参数名> <参数描述>
   * @param {<类型1|类型2>} [<参数名>] <参数描述>
   * @returns {<类型1|类型2>} <返回值描述>
   * @attribute <属性名>
   *   <属性描述>
   * @attribute <属性名>
   *   <属性描述>
   * @fires <事件名>
   *   <事件描述>
   * @fires <事件名>
   *   <事件描述>
   * @description
   *   <长描述(可包含 HTML 代码)>
   * @example
   *   <示例代码>
   * @example
   *   <示例代码>
   * @requires
   * @since
   * @deprecated
   * @see <参考链接>
   * @see <参考链接>
   */
<可选的换行>
<本方法的私有变量>

<本方法的主体代码>

...

})();
