<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>OurJS 入门指南</title>
<script src="../our.js"></script>
<script src="../scripts/common_loader.js"></script>
<script src="../scripts/prettify.js"></script>
<link rel="stylesheet" href="../stylesheets/prettify.css">
<style>
em { font-style: normal; text-decoration: underline; }
col.list { width: 430px; }
td { vertical-align: top; }
</style>
<script>
document.on('domready', function() {
  // 代码高亮。
  $(document.body).find('pre').forEach(function($pre) {
    $pre.addClass('prettyprint');
  });
  prettyPrint();
});
</script>
</head>
<body>
<div id="content" data-outline="enabled">
<h1>OurJS 入门指南</h1>

<h2>使用和下载</h2>
<h3>使用方式</h3>
<p>要使用 OurJS，只需要在页面中引入 our.js 即可：</p>
<pre>
&lt;script src="path/to/our.js"&gt;&lt;/script&gt;
</pre>
<p>如果还需要使用 Widget，相应的脚本也要引入。如需要使用 TabPanel：</p>
<pre>
&lt;script src="path/to/our.js"&gt;&lt;/script&gt;
&lt;script src="path/to/tabpanel.js"&gt;&lt;/script&gt;
</pre>
<blockquote>
  <p class="common">脚本文件的具体路径取决于项目的目录设置。</p>
</blockquote>

<h3>下载地址</h3>
<p>要下载 OurJS，请<a href="../download/" target="_blank" class="link">点击此处</a>。</p>

<h2>处理 JS 原生对象</h2>
<p>JS 原生对象是指 JS 语言本身提供的对象，它们都有各自的构造器。</p>
<p>OurJS 为各原生对象提供了多种扩展方法，以增强 JavaScript 的处理能力：</p>
<pre>
var list = [0, 1, 2, 3, 4];
list.reverse().getLast();
// list 反转后的最后一个元素是 0。
</pre>
<pre>
Object.mixin(defaultConfig, newConfig, {whiteList: Object.keys(defaultConfig)});
// 让 newConfig 覆盖 defaultConfig 的同名属性。
</pre>
<pre>
var day = Date.parseExact('2010-03-17 20:23:00').getDay();
// day 的值为 3，2010年3月17日是星期三。
</pre>
<blockquote>
  <p>JS 原生对象的相关 API 请查阅 <a href="../docs/api.html" target="_blank" class="link">参考文档 - API 参考</a> 左列的“JS Native Objects”部分。</p>
</blockquote>

<h2>处理浏览器内置对象</h2>
<p>浏览器的内置对象是指与浏览器或当前文档相关的对象，它们都是唯一的实例，不能被创建（它们的构造器是对开发者隐藏的）。</p>
<p>OurJS 为常用的浏览器内置对象也提供了扩展方法或属性：</p>
<pre>
if (navigator.isChrome) ...
// OurJS 为 navigator 对象扩展了一些列的属性，用于判断当前的浏览器类型。
</pre>
<pre>
var targetId = location.parameters.id || 1;
// location 对象的 parameters 属性包含了当前页面 url 中携带的所有参数。
</pre>
<pre>
var username = localStorage.getItem('username');
// IE6 IE7 中原本是不支持 localStorage 的，但 OurJS 对它们进行了增强，使其可以像现代浏览器一样支持本地存储（可以跨路径）。
</pre>
<blockquote>
  <p>相关演示请参考 <a href="../demos/navigator/" target="_blank" class="link">基本功能演示 - 浏览器信息</a> 和 <a href="../demos/storage/" target="_blank" class="link">基本功能演示 - 存储</a>。</p>
</blockquote>
<blockquote>
  <p>浏览器内置对象的相关 API 请查阅 <a href="../docs/api.html" target="_blank" class="link">参考文档 - API 参考</a> 左列的“Browser Built-in Objects”部分。</p>
</blockquote>

<h2>获取、创建和处理 DOM 对象</h2>
<p>OurJS 可以处理的 DOM 对象有<strong>窗口</strong>、<strong>文档</strong>和<strong>元素</strong>三种类型<sup>1</sup>。</p>
<p>其中窗口和文档对象也是特殊的浏览器内置对象，它们在页面中也是唯一的<sup>2</sup>实例，可以通过访问 window 和 document 来直接获取。</p>
<p>元素对象有多个实例，它们通常都是 DOM 树上的节点。可以创建新的元素对象，也可以对现有的元素对象进行修改或删除。</p>
<ol class="comment">
  <li>OurJS 并没有针对除文档和元素外的其他节点类型进行扩展，因为极少需要直接操作这些类型的数据。</li>
  <li>如果页面中有通过 frame 嵌入的另一个页面，那么这个被嵌入的页面有其自己的窗口和文档对象。</li>
</ol>

<h3>为窗口对象扩充的方法</h3>
<p>可以通过调用 OurJS 在窗口对象上扩展的几个与视口有关的方法，来获取视口的相关信息：</p>
<pre>
var width = window.getClientSize().width;
// 获取视口可视区域的宽度。
</pre>
<pre>
var height = window.getScrollSize().height;
// 获取视口滚动区域的高度。
</pre>
<pre>
var pageOffset = window.getPageOffset();
// 获取视口的滚动偏移量。
</pre>

<h3>为文档对象扩充的方法</h3>
<p>可以通过 document.$ 来获取和创建<strong>一个（而不是多个）</strong>元素：</p>
<pre>
var $container = document.$('#container');
// 获取 id 为 container 的元素。这相当于 document.getElementById('container')。
</pre>
<pre>
var $message = document.$('&lt;dl class="message"&gt;&lt;dt&gt;&lt;/dt&gt;&lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt;');
// 创建一个包含了 DT 和 DD 元素的 DL 元素。
</pre>
<p>可以使用 $ 来代替 document.$，以便于使用。</p>
<blockquote>
  <p>
    从这里开始，你会发现一些变量以 $ 开头，如上边两个例子中的 $container 和 $message，OurJS 的所有演示代码（也包括源码）中都会使用这样的方式来标识一个元素对象，以使代码更易读。<br>
    实际开发中，在为元素类型的变量或形参命名时（不包括属性名），也建议这么做。
  </p>
</blockquote>
<p>需要动态添加新的样式规则时，可以调用以下方法：</p>
<pre>
document.addStyleRules([
  '#id .class_name { display: block; }',
  '#id .class_name a { text-decoration: none; }'
]);
// 数组的每一项为一条规则。
</pre>
<p>需要动态加载新的脚本时，可以调用以下方法：</p>
<pre>
document.loadScript('http://your.domain/path/to/data.js', {
  charset: 'gbk',
  onLoad: function() {
    ...
  }
});
// 这个方法不受同源策略的限制，可以加载任何位置的脚本。
</pre>

<h3>为元素对象扩充的方法</h3>
<p>OurJS 为元素类型的对象扩展了一些常用的方法，如处理类和样式、处理自定义数据、获取位置和尺寸、获取相关元素、修改内容或位置等。</p>
<p>调用为元素扩展的方法时，和调用它们的原生方法或属性的方式是一样的：</p>
<pre>
if ($input.offsetWidth) {
  $input.addClass('active').focus();
}
// addClass 是为处理元素的类而添加的扩展方法。
</pre>
<p>
  上一节中提到，OurJS 提供的获取和创建元素的 API document.$ 每次只能获取或创建一个元素。<br>
  OurJS 在处理元素时，所有相关的 API 也都是针对单个元素进行的。
</p>
<p>虽然可以通过调用一个元素的 find 或 getChildren 方法来获取一批元素（实际是一个数组），但 OurJS 并没有提供“批量操作元素”的方法。如果一定要对一批元素进行操作，则需要遍历这些元素，并对其中的每一个单独进行操作：</p>
<pre>
&lt;style&gt;
.highlight_word { background: yellow; color: red; }
&lt;/style&gt;
...
&lt;script&gt;
$container.find('span.word').forEach(function($item) {
  $item.addClass('highlight_word');
});
// 找到 $container 的<em>后代元素中所有类名包含 'word' 的 SPAN 元素</em>，为它们添加 'highlight_word' 类以使它们高亮显示。
&lt;/script&gt;
</pre>
<p>
  OurJS 不提倡对元素进行批量操作，批量操作不符合常见的程序设计思路，并且代码的意图也不够明显。<br>
  OurJS 提倡的是只针对单一元素进行操作，这种做法可以使代码的意图更明显，也更严谨。
</p>
<p>
  这种编程风格和 jQuery 的区别很大。如果开发者习惯了 jQuery 的方式，在使用 OurJS 之前应该转换一下思路 —— 恰当的设计可以避免很多需要“批量操作元素”的场景：<br>
  使用 JS 来修改 DOM 树本质是在修改 DOM 节点的“状态”。通常来讲，同时修改多个节点的“状态”以改变其“含义”及“表现”，不如只修改一个节点的“状态”来改变这个分支内特定后代节点的“含义”及“表现”。后者更易于掌控，并能杜绝意料外的误操作。
</p>
<p>如上例可以修改为：</p>
<pre>
&lt;style&gt;
.highlight span.word { color: silver; font-style: italic; }
&lt;/style&gt;
...
&lt;script&gt;
$container.addClass('highlight');
// 为 $container 添加 'highlight' 类，这样其<em>后代元素中所有类名包含 'word' 的 SPAN 元素</em>都会自动高亮显示。
&lt;/script&gt;
</pre>
<blockquote>
  <p>相关演示请参考 <a href="../demos/dom/" target="_blank" class="link">演示 - DOM</a>。</p>
</blockquote>
<blockquote>
  <p>DOM 对象的相关 API 请查阅 <a href="../docs/api.html" target="_blank" class="link">参考文档 - API 参考</a> 中列的“DOM Objects”部分。</p>
</blockquote>

<h2>处理事件</h2>
<p>OurJS 提供了两种事件模型 —— <strong>DOM 事件模型</strong> 和 <strong>JS 事件模型</strong>，其中 DOM 事件模型用于处理用户在交互时产生的 DOM 事件（OurJS 的 Widget 使用的也是 DOM 事件模型），而 JS 事件模型则在编写组件和应用模块时使用（OurJS 的 Animation 和 Request 均使用了 JS 事件模型）。</p>
<p class="referral">这两种事件模型的对比如下：</p>
<table>
  <colgroup>
    <col>
    <col class="list">
    <col class="list">
  </colgroup>
  <thead>
    <tr>
      <th></th>
      <th>DOM 事件模型</th>
      <th>JS 事件模型</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>应用的对象</th>
      <td>window 对象、document 对象和所有 Element 对象。</td>
      <td>通过调用 new EventTarget() 获得的新对象，或通过调用 EventTarget.create(object) 处理后的 object 对象。</td>
    </tr>
    <tr>
      <th>事件的<br>触发方式</th>
      <td>在特定的行为发生时自动触发，或者通过调用 fire 方法触发。</td>
      <td>只能通过调用 fire 方法触发。</td>
    </tr>
    <tr>
      <th>事件对象的<br>创建和应用</th>
      <td>当事件被触发时，除少数特殊事件类型外，均会产生事件对象，并将其作为参数传入监听器。</td>
      <td>当事件被触发时，任何事件类型均会产生事件对象，并将其作为参数传入监听器。</td>
    </tr>
    <tr>
      <th>事件对象的<br>属性和方法</th>
      <td>事件对象有多个属性和方法，其中“键盘事件”、“鼠标事件”和一些特殊的事件类型还有特殊的附加属性。<br>在调用 fire 方法时也可以附加其他自定义属性。</td>
      <td>事件对象默认只有 type 和 target 两个属性。<br>在调用 fire 方法时也可以附加其他自定义属性。</td>
    </tr>
    <tr>
      <th>事件对象的<br>传播特性</th>
      <td>某些类型的事件对象可以在 DOM 树中传播。</td>
      <td>无此特性。</td>
    </tr>
    <tr>
      <th>事件对象的<br>默认行为</th>
      <td>某些类型的事件对象会有默认行为，并且其中的一部分还可以阻止其默认行为的发生。</td>
      <td>无此特性。</td>
    </tr>
    <tr>
      <th>添加监听器</th>
      <td colspan="2">均使用 on 方法添加事件监听器。</td>
    </tr>
    <tr>
      <th>删除监听器</th>
      <td colspan="2">均使用 off 方法删除已添加的事件监听器，并且它们的参数的含义也一致。</td>
    </tr>
    <tr>
      <th>代理事件监听</th>
      <td>可以在调用 on 方法时，使用 :relay(selector) 对可以冒泡的事件进行代理监听。</td>
      <td>不支持。</td>
    </tr>
    <tr>
      <th>组合事件监听</th>
      <td>不支持。</td>
      <td>可以在调用 on 方法时，使用 [masterType>slaveType] 对两种事件进行组合监听。</td>
    </tr>
  </tbody>
</table>

<h3>DOM 事件模型</h3>
<p>DOM 事件模型用于处理 DOM 对象的事件的触发、监听、代理监听等。</p>
<p>本模型对一些常见的事件类型做了兼容性处理，可以保证在各浏览器下均有相同的表现。</p>
<p>窗口、文档和元素对象均可以直接使用 DOM 事件模型处理事件。</p>

<h4>添加一个事件监听器</h4>
<p>使用 on 方法来添加事件监听器：</p>
<pre>
window.on('resize', listener);
// 当 listener 被调用时，this 的值为被监听的 window 对象。
</pre>

<h4>添加多个事件监听器</h4>
<p>可以在一个 DOM 对象上为同一类型的事件添加任意个监听器，这可以通过多次调用 on 方法来完成：</p>
<pre>
$element.on('click', listener1);
...
$element.on('click', listener2);
// 如果一个 DOM 对象的一类事件有多个监听器，那么当这类事件发生时，这些监听器被调用的顺序和它们被添加的顺序是一致的。
</pre>
<p>也可以使用相同的监听器来处理一个 DOM 对象上不同种类型的事件，使用逗号分割各事件名称即可：</p>
<pre>
document.on('mouseenter, mouseleave', listener);
</pre>

<h4>代理事件监听</h4>
<p>
  代理事件监听是一个很重要的功能，OurJS 可以在为一个元素添加监听器时，使用“代理选择符”来对指定的后代元素代理事件监听。<br>
  “代理选择符”的写法为 :relay(selector)<sup>1</sup>，其中 relay 即“接替”，selector 可以为任意 CSS 选择符，它们合在一起表示“接替<em>以目标元素为起点，能被 selector 选中的后代元素</em>来处理传播到<em>这些元素</em>的事件”，亦即为这些后代元素代理事件监听：
</p>
<pre>
$element.on('mouseenter<strong>:relay(li.enabled)</strong>', listener);
// $element 元素将为其所有标签名为 li 且类名包含 enabled 的后代元素代理监听 mouseenter 事件。
// 当 listener 被调用时，this 的值为被代理监听的 LI 元素。
</pre>
<p>在 IE6 IE7 IE8 中，发生在元素对象上的事件如果可以传递，则只能传递到 document 对象，而不会传递到 window 对象，因此不要让 window 对象为其他元素代理事件监听，以保持兼容。</p>
<ol class="comment">
  <li>这个语法来自 MooTools。</li>
</ol>

<h4>删除已添加的事件监听器</h4>
<p>要选择性的删除已添加的、特定的一个或多个监听器时，首先应在添加这些监听器时使用“标签”来对它们进行标记。<br>“事件类型”、“代理选择符”和“标签”的组合称为“事件名称”，在调用 off 方法删除事件时就是以“事件名称”为依据对指定的监听器进行删除的：</p>
<pre>
$element.on('input', listener1).on('input<strong>.foo</strong>', listener2);
// 为 $element 添加两个事件监听器 listener1 和 listener2，它们监听的事件名称分别为 'input' 和 'input<strong>.foo</strong>'。
...
$element.on('input', listener3);
// 再为 $element 添加一个事件监听器 listener3，它监听的事件名称仍为 'input'。
...
$element.off('input');
// 删除在 $element 上添加的所有监听 'input' 事件（注意 'input' 是事件名称而不是事件类型）的监听器，即 listener1 和 listener3，此时监听 'input<strong>.foo</strong>' 事件的监听器 listener2 仍然生效。
</pre>
<p>可以同时设定“代理选择符”和“标签”：</p>
<pre>
$element.on('click:relay(a).foo', listener1);
...
$element.on('<strong>click:relay(a).bar</strong>', listener2);
...
$element.off('<strong>click:relay(a).bar</strong>');
// 删除代理事件监听器 listener2。
</pre>
<p>OurJS 没有提直接供删除一个 DOM 对象上某类型的所有监听器的功能<sup>1</sup>，开发者每次删除监听器时都应明确指定要删除的监听器所监听的“事件名称”，这个设计是为了避免监听器被误删<sup>2</sup>。</p>
<ol class="comment">
  <li>在调用一个元素的 replace 或 remove 方法时，可以通过设置参数 keepListeners 为 false 来清除为该元素添加的所有事件监听器。</li>
  <li>要避免一个监听器被误删，应在添加该监听器时，在“事件名称”中添加一个具有明确含义的“标签”，并确保整个应用中此“事件名称”是唯一的。</li>
</ol>

<h4>触发某类事件</h4>
<p>使用 fire 方法来触发某类事件：</p>
<pre>
window.fire('resize');
</pre>
<p>调用 fire 方法时，仅会运行目标 DOM 对象上使用 OurJS 添加的监听器，并且其默认行为也将被阻止：</p>
<pre>
$a.fire('click');
// 并不会让浏览器跳转到 $a 链接的目标地址。如果要跳转，应调用它的 click 方法，即 $a.click()。
</pre>
<p>
  当需要一个元素执行某种行为时，不应该使用 fire 方法，而应该直接调用对应的方法，如 click、select、submit 等。<br>
  这些方法在调用后，大多数情况下也会触发一个同名事件<sup>1</sup>。
</p>
<ol class="comment">
  <li>
    目前在所有浏览器中，调用 submit 方法都不会触发 submit 事件，这是为了兼容互联网上的旧页面而有意设计的特征。<br>
    在目前互联网上存在的页面中，大量页面都在表单对象的 onsubmit 属性上添加了验证表单域的函数，并在函数中直接阻止事件对象的默认行为，当验证通过时再调用 submit 方法来提交表单（而不是在验证失败时阻止事件对象的默认行为），如果此时再触发 submit 事件，在这些页面上就会导致死循环。
  </li>
</ol>

<h4>事件对象</h4>
<p>除了少数特殊类型的事件外（如 window 的 beforeunload 事件），其他所有类型的事件监听器被调用时，均会被传入本次事件发生时产生的事件对象。</p>
<p>所有事件对象都有一些特定的属性，使用 fire 方法触发的事件产生的事件对象也不例外：</p>
<pre>
document.on('mousewheel', function(e) {
  if (e.shiftKey && e.wheelUp) {
    ...
  }
});
// 所有键盘和鼠标事件对象都有 shiftKey 属性，仅有 mousewheel 事件对象才有 wheelUp 属性。
</pre>
<p>所有事件对象都有控制其传播和默认行为的方法：</p>
<pre>
$element.on('click', function(e) {
  ...
  e.stopPropagation();
});
// 阻止本次点击事件的传播。
</pre>
<pre>
$element.on('click', function(e) {
  ...
  e.preventDefault();
});
// 阻止本次点击事件的默认行为。
</pre>
<pre>
$element.on('click', function(e) {
  ...
  return false;
});
// 监听器返回 false 即代表调用了事件对象的 stopPropagation 和 preventDefault 方法。
</pre>
<blockquote>
  <p>一些事件类型只有特定的 DOM 对象才支持，并且不是所有类型的事件都可以被代理。关于 DOM 事件的类型与特征的对应关系，请查阅 <a href="../docs/events.html" target="_blank" class="link">参考文档 - 可用事件类型列表</a>。</p>
</blockquote>

<h3>JS 事件模型</h3>
<p>JS 事件模型用于处理 JS 原生对象的事件的触发、监听、组合监听等。</p>
<p>只有 EventTarget 对象才能使用 JS 事件模型来处理事件。</p>

<h4>创建一个 EventTarget 对象</h4>
<p>通过调用 new EventTarget() 获得的新对象，或经过 EventTarget.create(object) 处理后的 object 对象，都可以被叫做一个 EventTarget 对象：</p>
<pre>
var object = new EventTarget();
// 新建一个 EventTarget 对象。
</pre>
<pre>
var object = {key: 'value'};
EventTarget.create(object);
// 使一个已有的对象成为 EventTarget 对象。
</pre>

<h4>添加一个事件监听器</h4>
<p>使用 on 方法来添加事件监听器：</p>
<pre>
eventTarget.on('someType', listener);
// 当 listener 被调用时，this 的值为被监听的 eventTarget 对象。
</pre>

<h4>添加多个事件监听器</h4>
<p>可以在一个 EventTarget 对象上为同一类型的事件添加任意个监听器，这可以通过多次调用 on 方法来完成：</p>
<pre>
eventTarget.on('anotherType', listener1);
...
eventTarget.on('anotherType', listener2);
// 如果一个 eventTarget 对象的一类事件有多个监听器，那么当这类事件发生时，这些监听器被调用的顺序和它们被添加的顺序是一致的。
</pre>
<p>也可以使用相同的监听器来处理一个 EventTarget 对象上不同种类型的事件，使用逗号分割各事件名称即可：</p>
<pre>
eventTarget.on('someType, anotherType', listener);
</pre>

<h4>组合事件监听</h4>
<p>
  组合事件监听可以指定一个监听器仅在 masterType 和 slaveType 两种类型的事件均被触发后才会被调用。<br>
  当 slaveType 事件的处理必须在 masterType 事件发生后才能进行时，使用 [masterType>slaveType] 的格式即可对 masterType 和 slaveType 这两类事件进行组合监听。
</p>
<p>这两种类型的事件的含义并不相同：</p>
<ul>
  <li>
    <p>在一次组合事件监听中，masterType 事件对象永远是“可组合”的，只需要触发一次 masterType 事件，该事件对象即可以和任意多个 slaveType 事件对象进行组合。</p>
    <p>如果 masterType 先被触发一次或多次，则只保留最新的 masterType 事件对象用于组合。此后每当 slaveType 被触发时，产生的 slaveType 事件对象都会立即与最新的 masterType 事件对象进行组合。</p>
  </li>
  <li>
    <p>在一次组合事件监听中，slaveType 事件对象只能和 masterType 事件对象组合一次。</p>
    <p>如果 slaveType 先被触发一次或多次，则每次触发的 slaveType 事件对象都会自动以队列的形式被保存，并将在 masterType 被触发后按照顺序逐个与最新的 masterType 事件对象进行组合。</p>
  </li>
</ul>
<p>在编写组件时使用组合事件监听，可以提高组件的易用性：</p>
<pre>
var popup = EventTarget.create({
  // 调用 init 方法以进行初始化工作，并触发 init 事件。
  init: function() {
    this.element = $('&lt;div style="display: none; right: 0; bottom: 0; width: 200px; height: 150px; border: 2px solid steelblue; background: whitesmoke; text-align: center; line-height: 150px;"&gt;&lt;/div&gt;').insertTo(document.body);
    this.fire('init');
  },
  // show 方法可以在任何时间调用，此处仅仅触发 show 事件，并在事件对象上附加传入的 text。
  show: function(text) {
    this.fire('show', {text: text});
  }
})
    // 当 init 和 show 事件均发生过时才会调用组合事件的监听器。
    .on('[init>show]', function(_, e) {
      this.element.innerText = e.text;
      this.element.setStyles({display: 'block', position: 'fixed'});
    });
...
// 在 popup 对象在可用后，即可随时调用其 show 方法，而不必担心“未初始化”的问题。
popup.show('Hello World');
...
// 在恰当的时机，调用其 init 方法。如果曾经调用过其 show 方法，那么 popup 将在这时弹出，并显示在调用其 show 方法时传入的字符串。
popup.init();
</pre>
<p>在上例中，popup 对象的 show 方法是同步方法，最终信息的显示却是异步的（取决于调用 popup 的 init 方法的时间），这是因为信息的显示并非由 show 方法直接导致，调用 show 方法只是显示信息的必要条件之一。开发者应了解这个机制，避免产生误解。</p>
<p>使用组合事件监听，还可以很容易的实现异步调用队列：</p>
<pre>
var queue = new EventTarget();
queue.on('[flush>insert], [flush>delete]', function(_, e) {
  console.log(e.type + '-' + e.data);
});
queue.fire('insert', {data: '1'});
queue.fire('delete', {data: '2'});
queue.fire('delete', {data: '3'});
queue.fire('insert', {data: '4'});
queue.fire('flush');
// 输出如下：
// insert-1
// delete-2
// delete-3
// insert-4
</pre>

<h4>删除已添加的事件监听器</h4>
<p>要选择性的删除已添加的、特定的一个或多个监听器时，首先应在添加这些监听器时使用“标签”来对它们进行标记。<br>“事件类型”和“标签”的组合或“组合事件类型”和“标签”的组合都称为“事件名称”，在调用 off 方法删除事件时就是以“事件名称”为依据对指定的监听器进行删除的：</p>
<pre>
eventTarget.on('someType', listener1).on('someType<strong>.foo</strong>', listener2);
// 为 eventTarget 添加两个事件监听器 listener1 和 listener2，它们监听的事件名称分别为 'someType' 和 'someType<strong>.foo</strong>'。
...
eventTarget.on('someType', listener3);
// 再为 eventTarget 添加一个事件监听器 listener3，它监听的事件名称仍为 'someType'。
...
eventTarget.off('someType');
// 删除在 eventTarget 上添加的所有监听 'someType' 事件（注意 'someType' 是事件名称而不是事件类型）的监听器，即 listener1 和 listener3，此时监听 'someType<strong>.foo</strong>' 事件的监听器 listener2 仍然生效。
</pre>
<p>使用组合事件监听时也一样：</p>
<pre>
eventTarget.on('[masterType>slaveType].foo', listener1);
...
eventTarget.on('<strong>[masterType>slaveType].bar</strong>', listener2);
...
eventTarget.off('<strong>[masterType>slaveType].bar</strong>');
// 删除组合事件监听器 listener2。
</pre>
<p>OurJS 没有提直接供删除一个 EventTarget 对象上某类型的所有监听器的功能，开发者每次删除监听器时都应明确指定要删除的监听器所监听的“事件名称”，这个设计是为了避免监听器被误删<sup>1</sup>。</p>
<ol class="comment">
  <li>要避免一个监听器被误删，应在添加该监听器时，在“事件名称”中添加一个具有明确含义的“标签”，并确保整个应用中此“事件名称”是唯一的。</li>
</ol>

<h4>触发某类事件</h4>
<p>使用 fire 方法来触发某类事件：</p>
<pre>
eventTarget.fire('someType');
</pre>

<h4>事件对象</h4>
<p>事件对象默认只有 type 和 target 两个属性。在调用 fire 方法时也可以附加其他自定义属性。</p>

<blockquote>
  <p>相关演示请参考 <a href="../demos/event/" target="_blank" class="link">演示 - 事件</a>。</p>
</blockquote>

<h2>动画</h2>
<p>OurJS 提供了一套功能强大、控制灵活的动画引擎。</p>
<p>动画引擎会以一个预设的最大 FPS（通过 Animation.fps 来指定）来播放动画，播放时实际的 FPS 是一个浮动值，具体视计算机的速度而定。当计算机的速度比期望的慢时，动画会以“跳帧”的方式来播放，这样可以确保整个动画的消耗时间尽可能的接近期望值。</p>
<p>如果页面中的多个（任何类型的）动画同时处于播放状态，动画引擎将同频同步播放这些动画的每一帧，以减少浏览器 reflow 和 repaint 的次数，提高渲染效率，使动画能够播放得更流畅。</p>
<p>动画引擎还支持多种事件的监听或回调，如常见的“播放每一桢后”和“全部播放完毕后”等事件。</p>
<p>动画引擎的控速函数 100% 兼容 CSS3 的 transition-timing-function。</p>
<p>在使用动画时，可以根据情况选择<strong>在 Element.prototype 上提供的动画</strong>（单个元素参与的动画或需要播放简单的补间动画时）或<strong>使用 Animation 创建的动画</strong>（多个元素参与的动画或需要反转动画时）。</p>

<h3>在 Element.prototype 上提供的动画</h3>
<p>这种动画很容易配置和使用，并为常用的事件提供了回调函数。</p>
<p>这种动画分为 morph/highlight/fade/smoothScroll 四种类型，分别用于实现平滑渐变、高亮、淡入淡出、平滑滚动的动画效果。</p>
<p>它们的特点是：</p>
<ul>
  <li>关注点是当前元素，即只能改变当前元素的样式。</li>
  <li>每次运行都是以元素的当前状态为起点。</li>
  <li>同类动画在连续调用时，将自动合并播放（停止旧的播放新的），其中 fade 类型的动画还会对时间进行合并处理（新动画的最长播放时间为旧动画的已播放时间）。</li>
</ul>
<p>举例如下：</p>
<pre>
$element.morph({width: '+=100'}, {duration: 2000});
// 每次调用都会在两秒内将 $element 的宽度增加 100px。
// 如果在一次调用的 1 秒后再次调用（此时将停止之前尚未播放完毕的动画），$element 将以第二次调用的时间点的当前宽度作为起始宽度，在两秒内将其宽度再增加 100px。
</pre>

<h3>使用 Animation 创建的动画</h3>
<p>这种动画的配置和使用稍复杂一些，但却能提供更精确的控制手段和更丰富的事件。</p>
<p>
  可以为 Animation 的实例添加多个动画剪辑，以实现复杂的动画效果和动画队列。<br>
  所有 Animation 的实例也都是一个 EventTarget 对象。Animation 还提供了灵活的控制手段，可以随时暂停或倒放。
</p>
<p>它们的特点是：</p>
<ul>
  <li>关注点是动画效果，可以改变多个元素的样式。</li>
  <li>创建时即确定起始和结束状态，可以精确控制，如暂停和倒放。</li>
  <li>支持多个动画剪辑，支持多种事件，能实现复杂的动画效果和动画队列。</li>
</ul>
<p>举例如下：</p>
<pre>
var animation = new Animation().addClip(Animation.createStyleRenderer($menu, {
  borderLeftWidth: 10,
  backgroundColor: 'mediumorchid',
  color: 'white'
}), 0, 200, 'ease');
$menu
    .on('mouseenter', function() {
      animation.play();
    })
    .on('mouseleave', function() {
      animation.reverse();
    });
// 本例的动画效果只影响一个元素，通过添加多个动画剪辑，可以同时影响任意数目的元素。
// 鼠标进入该元素后可以在任意时间离开，动画将在相应的时间点开始反向播放到初始状态。
</pre>

<blockquote>
  <p>相关演示请参考 <a href="../demos/animation/" target="_blank" class="link">演示 - 动画</a>。</p>
</blockquote>

<h2>远程请求</h2>
<p>远程请求是通过 Request 对象来实现的。</p>
<p>所有 Request 的实例也都是一个 EventTarget 对象，并且每个实例都对应一个资源，实例创建后可以重复使用。</p>
<p>从数据交互的角度看，一次请求有“成功”、“失败”、“超时”三种状态，因此大多数库中都预置了这些类型的事件或回调。</p>
<p>
  从应用的角度看，对一个资源的请求结果未必只有以上三种状态，响应状态码是 200 的情况未必代表“操作成功”。<br>
  因此 Request 设计为每发送一个请求就必然会收到一个响应，发送请求后，无论何种情况（本次请求超时或被取消）均会触发 finish 事件。这样的设计可以简化应用逻辑，便于在请求结束时能够在 finish 事件监听器中统一处理一些状态的设定或恢复，如将 start 事件监听器中呈现到用户界面的提示信息隐藏。
</p>
<p>在触发 finish 事件之前，根据请求的实际状态，会首先触发 abort（请求被取消）、timeout（请求超时）和complete（请求完成）事件。</p>
<p>根据 Request 使用场景的不同，有 XHR 和 JSONP 两种模式。</p>

<h3>XHR 模式</h3>
<p>如果请求的资源在本域内，应使用 XHR 模式。当不指定 mode 选项或将其指定为 'xhr' 时，即启用 XHR 模式：</p>
<pre>
var getUserinfo = new Request('path/to/userinfo', {
  maxTime: 5000,
})
    .on('finish', function(e) {
      ...
    });
...
getUserinfo.send({userid: 32768});
</pre>
<p>XHR 模式的 Request 可以通过 async 选项即可指定使用同步或异步方式。</p>

<h3>JSONP 模式</h3>
<p>如果请求的资源不在本域内，应使用 JSONP 模式。将 mode 选项指定为 'jsonp' 时，即启用 JSONP 模式：</p>
<pre>
var getUserinfo = new Request('http://another.domain/path/to/userinfo', {
  mode: 'jsonp',
  maxTime: 5000,
})
    .on('finish', function(e) {
      ...
    });
...
getUserinfo.send({userid: 32768});
</pre>
<p>JSONP 模式的 Request 将永远使用异步方式进行数据交互，并且请求方法永远为 get。</p>

<blockquote>
  <p>相关演示请参考 <a href="../demos/request/" target="_blank" class="link">基本功能演示 - 远程请求</a>。</p>
</blockquote>

<h2>Widgets</h2>
<p>OurJS 提供的 Widgets 是一类特殊的元素，可以把一个 Widget 视为一种“<strong>高级可替换元素</strong>”。</p>
<p>
  当一个元素成为 Widget 时，将获得新的属性、方法，具备新的行为，并能触发新的事件。<br>
  由于 Widgets 的本质仍然是元素，因此其新增的事件类型仍使用 OurJS 为 DOM 对象提供的事件模型，即这些事件产生的事件对象是可以在 DOM 树中传递的，并且可以被代理。
</p>
<p>一些 Widgets 甚至不需要写任何脚本去初始化，即可直接使用。</p>

<h3>基本用法</h3>
<p>以“模态对话框（Dialog）”为例，要将一个元素“升级”为 Dialog Widget，首先应确保页面载入了对应的 Widget 解析脚本：</p>
<pre>&lt;script src="path/to/widgets/dialog.js"&gt;&lt;/script&gt;</pre>
<p>然后在目标元素上添加一个格式为 widget-<strong>type</strong> 的 class，并使用 data-<strong>config</strong>="<strong>value</strong>" 属性来定义 Widget 的配置即可<sup>1</sup>：</p>
<pre>&lt;div id="notice" class="widget-dialog" data-animation="slide"&gt;&lt;/div&gt;</pre>
<p>这样，目标元素就变成了一个 Dialog Widget，它将具备新的特性（具体请参考“Widget - 模态对话框”的说明文档）。对这个 Dialog Widget 的操作在 domready 事件发生后即可进行。</p>
<ol class="comment">
  <li>其中 <strong>type</strong> 表示 Widget 的类型，<strong>config</strong> 和 <strong>value</strong> 表示 Widget 的可配置项及其值。</li>
</ol>

<h3>定制和扩展</h3>
<p>Widget 本质仍是一个元素，因此其外观仍和其他普通元素一样可以定制：</p>
<pre>
&lt;style&gt;
#notice { width: 600px; height: 400px; background: steelblue; }
&lt;/style&gt;
</pre>
<p>这样这个“模态对话框”就具备了新的外观。</p>
<p>当需要打开这个“模态对话框”的时候，可以调用该元素新增的 open 方法来实现：</p>
<pre>
var $notice = $('#notice');
$notice.open();
// 这个“模态对话框”将根据其配置，在相应的位置显示。
</pre>
<p>如果需要在这个“模态对话框”关闭的时候执行某个方法，可以在它的事件监听器中处理：</p>
<pre>
var $notice = $('#notice').on('close', function() {
  // 进行必要的处理。
});
...
$notice.open();
...
$notice.close();
// 执行该元素的 close 方法时，会自动触发 close 事件（这个事件是可以冒泡和被代理的）。
</pre>

<h3>设计新的 Widget</h3>
<p>当需要设计新的 Widget 时，可以参考已有的 Widget 代码进行设计。</p>

<blockquote>
  <p>关于 Widgets 的更多说明信息及演示请参考 <a href="../widgets/" target="_blank" class="link">Widgets</a> 菜单中的各项内容。</p>
</blockquote>

<blockquote>
  <p>Widgets 的相关 API 请查阅 <a href="../docs/api.html" target="_blank" class="link">参考文档 - API 参考</a> 右列的“Widgets”部分。</p>
</blockquote>

</div>
</body>
</html>
